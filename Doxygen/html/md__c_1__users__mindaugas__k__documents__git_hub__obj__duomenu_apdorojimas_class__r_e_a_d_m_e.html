<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Obj_Duomenu_apdorojimas_class: Įdiegimo instrukcija</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="023.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Obj_Duomenu_apdorojimas_class
   &#160;<span id="projectnumber">v2.0</span>
   </div>
   <div id="projectbrief">The third project of VU ISE OOP course</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Įdiegimo instrukcija </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><ol type="1">
<li>Clone'inam repositoriją <code>$ git clone <a href="https://github.com/gitguuddd/Obj_Duomenu_apdorojimas.git">https://github.com/gitguuddd/Obj_Duomenu_apdorojimas.git</a></code></li>
<li>Compile'inam programą paleisdami CMakeLists.txt failą</li>
<li>Norint nuskaityti informaciją nuo failo reikia sukurti kursiokai.txt failą su tokia struktūra <div class="fragment"><div class="line">Pavarde     Vardas      ND1  ND2  ND3  ND4  ND5  ND6  ND7  ND8  Egzaminas</div><div class="line">Pavarde1    Vardas1     10   9    4    6    4    5    0    4    7</div><div class="line">Pavarde2    Vardas2     10   0    6    7    9    4    2    5    3</div><div class="line">Pavarde3    Vardas3     10   0    3    b    5    2    1    4    5</div></div><!-- fragment --> <h2>- Paleidžiame programą </h2>
</li>
</ol>
<h2>Naudojimosi instrukcija</h2>
<ul>
<li>Paleidųs programą programa paklaus vartotojo kokiu režimu jis nori vykdyti programą: išsamiu ar konkrečiu</li>
<li>Išsamus režimas pasižymi labai didele pasirinkimo galimybe - kiekvienam generuojamam studentu failui galima priskirti skirtingą skaičių namų darbų, galutinio pažymio skaičiavimo būdą. Šis režimas yra apkrautas vartotojo įvestimi</li>
<li>Konkretus režimas kiek galima labiau sumažina vartotojo įvesčių kiekį - generuojant failus reikia tik vieną kartą įvesti namų darbų skaičių ir galutinio pažymio skaičiavimo būdą</li>
<li>Paleidųs programą ir pasirinkųs režimą bus matomas toks vaizdas <div class="fragment"><div class="line">Saugomi 0 studentu(o) duomenys, pasirinkite ka daryti toliau:</div><div class="line">1. Ivesti studenta paciam</div><div class="line">2. Generuoti studenta</div><div class="line">3. Skaityti is failo</div><div class="line">4. Atspausdinti (galutinis pagal nd mediana)</div><div class="line">5. Atspausdinti (galutinis pagal nd vidurki)</div><div class="line">6. Generuoti studentu faila (v1.0)</div><div class="line">7. Skelti studentus i maladec ir L-laivo sarasus, atspausdinti</div></div><!-- fragment --></li>
<li>Pasirinkite norimą funkciją ivesdami jos numerį. Input'ai apsaugoti tai galima ir pasiaust :D</li>
<li>Po 1, 2 arba 3 funkcijos įvykdomo programa grįžta į meniu, atnaujinamas saugomų studentų rodiklio skaičius</li>
<li>4, 5, 7 funkcijos neveiks, jei nebus saugomi bent vieno studento duomenys <h2>- Po 4, 5, 6 arba 7 funkcijos įvykdymo programa baigia darbą </h2>
</li>
</ul>
<h2>Versijų istorija (changelog)</h2>
<hr/>
 <h3><a href="https://github.com/gitguuddd/Obj_Duomenu_Apdorojimas_class/releases/tag/v1.5">v1.5</a></h3>
<p>(2019-05-07)</p>
<img src="./Memes/top-gear.jpeg" alt="alt text" class="inline"/>
 <b>Pridėta</b></p><ul>
<li><code>Stud</code> derived klasės abstrakti bazinė klasė <code>Humie</code></li>
<li><code>Important_Values</code> klasė kurioje saugomi ir apsaugomi seniau per visą programą buvę išmėtyti globalūs kintamieji</li>
<li><code>Stud</code> klasės &gt;&gt; ir &lt;&lt; operatoriai</li>
<li><code>Stud</code> klasės <code>scan_name</code> ir <code>scan_surname</code> funkcijos</li>
<li><code>handle_nd</code> funkcija skirta <code>ndcount</code> kintamojo įvedimo į <code>Important_Values</code> tikrinimui</li>
</ul>
<p><b>Koreguota</b></p><ul>
<li>Iš <code>Stud</code> klasės į <code>Humie</code> klasę perkelti <code>m_name, m_surname, m_nd</code> kintamieji ir su jais susyjusios funkcijos. Taip užtikrinama, kad <code>Humie</code> klasė saugos įvestus duomenis, o <code>Stud</code> klasė - išvedimui paruoštus duomenis</li>
<li>Panaikinti beveik visi padriki globalūs kintamieji (palikti globalūs vektoriai, dekai, listai ir t.t). Minėti kintamieji perkelti į <code>Important_Values</code> klasę</li>
<li>Dėl sutikto "circular include" teko pertvarkyt headeriuose include'intus kitus headerius :(</li>
<li>Realizuotų &gt;&gt; ir &lt;&lt; <code>Stud</code> klasės operatorių deka buvo pertvarkytos template'inė <code>read_file2</code> , nuskaitymo nuo <code>kursiokai.txt</code> failo <code>read_file2</code>, template'inė spausdinimo į failą <code>print_to_file</code> funkcijos</li>
<li>Į github pridėtas <code>build</code> aplankas su jame esančiu kursiokai.txt failu</li>
<li>Atnaujinta informacija apie programos struktūra</li>
</ul>
<p><b>Žinomos problemos/ką galima pagerinti</b></p><ul>
<li>Vis dar galima patobulinti programos struktūrą</li>
<li>Kintamųjų ir funkcijų pavadinimų standartai :DD</li>
</ul>
<hr/>
 <h3><a href="https://github.com/gitguuddd/Obj_Duomenu_Apdorojimas_class/releases/tag/v1.2">v1.2</a></h3>
<p>(2019-05-02)</p>
<img src="./Memes/Operator.png" alt="alt text" title="A mym" class="inline"/>
<p><b>Pridėta</b></p><ul>
<li><code>Rule of five</code> <code>Stud</code> klasės operatoriai</li>
<li>Įvairūs <code>Stud</code> klasės palyginimo operatoriai</li>
</ul>
<p><b>Koreguota</b></p><ul>
<li>Programos veikimo laiko skaičiavimas dabar realizuojamas per <code>Timer.h</code> klasę</li>
<li>Stud klasė ir jos funkcijos iš <code>Mutual.h</code> ir <code>Mutual.cpp</code> iškeliamos į <code>Stud.h</code> ir <code>Stud.cpp</code></li>
<li><code>Stud.h, Stud.cpp, Timer.h</code> failai laikomi classes aplankale</li>
<li>Programos metu sugeneruoti failai saugomi <code>build</code> aplankale <h2>- Dokumentacijoje atnaujinta informacija apie programos struktūrą </h2>
</li>
</ul>
<h3><a href="https://github.com/gitguuddd/Obj_Duomenu_Apdorojimas_class/releases/tag/v1.1">v1.1</a></h3>
<p>(2019-04-23)</p>
<p><b>Koreguota</b></p><ul>
<li><code>Stud</code> struktūra pakeičiama į <code>Stud</code> klasę</li>
<li>Iš klasės narių panaikinti tarpiniai <code>vid</code> ir <code>mvid</code> kintamieji, nes galutinio balo(vidurkis) ir galutinio balo(mediana) skaičiavimai vyksta setteriuose</li>
<li>Pagal <code>Clang-tidy</code> rekomendacijas keliose vietose panaudotas <code>std::move</code></li>
<li>Panaikinta daug perteklinių try-catch blokų</li>
</ul>
<p><b>Žinomi bugai/ ką galima patobulinti</b></p><ul>
<li>Programos struktūra is still a wreck</li>
<li>Kartais <code>L_laivas</code> STL konteineryje galima išvysti vieną studentą su galutiniu balu, kuris lygus <code>5</code>, galima custom predicate problema</li>
<li>Galima patobulinti ir pačią klasę - padaryti ją suprantamesne <h2>- Pats metas pradėti taikyti kintamųjų ir funkcijų pavadinimų standartus </h2>
</li>
</ul>
<h3><a href="https://github.com/gitguuddd/Obj_Duomenu_apdorojimas/releases/tag/v1.0.1">v1.0.1</a></h3>
<p>(2019-03-27)</p>
<p><b>Pridėta</b></p><ul>
<li>Funkcijos <code>t_gavo_skola, rask_Minkstus, rask_Minkstus_d, rask_Kietus, rask_Kietus_d</code></li>
<li>Papildomos užduoties siūlomi splitinimo variantai pridėti kaip papildoma <code>d</code> splitinimo strategija</li>
<li>Pridėta galimybė pasirinkti programos veikimo rėžima: išsamus/konkretus</li>
<li>Skeliant studentus naudojant papildomos užduoties algoritmus skėlimo laikai bus išvedami į <code>Papildomos_uzduoties_laikai.txt</code> failą</li>
<li>Kai vartotojas pats įveda vardą/pavardę programa tikrina ar varde/pavardėje yra tik raidės, atradųs kitokį simbolį vardas/pavardė yra keičiami į <code>BadInput</code></li>
</ul>
<p><b>Koreguota</b></p><ul>
<li>Sutvarkyti keli <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> failo bug'ai</li>
<li>Pertvarkyta <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> failo struktūra</li>
<li>visi <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> paveiksliukai sukelti į <code>Memes</code> folderį</li>
</ul>
<hr/>
 <h3><a href="https://github.com/gitguuddd/Obj_Duomenu_apdorojimas/releases/tag/v1.0">v1.0</a></h3>
<p>(2019-03-25)</p>
<p><b>Pridėta</b></p><ul>
<li>Prie naudojamos <code>c</code> splitinimo strategijos pridėtos <code>a</code> ir <code>b</code> strategijos (apie jas - vėliau)</li>
<li>Splitinimo strategijos pasirinkimo funkcija <code>Strat_pick</code></li>
</ul>
<p><b>Koreguota</b></p><ul>
<li>Sutvarkytas minor bug'as: išvedant skaičiavimus pagal mediana rašydavo, kad galutinis vertinimas buvo skaičiuotas pagal vidurkį</li>
<li>Pasirodo, kad listo nebuvo įmanoma panaudoti su didesniais studentų kiekiais vien dėl mano kaltės, nes neišvalydavau temp struktūros.</li>
<li>Paspartintas readinimas iš failo: eilutės duomenys nuskaitomi į temp struktūra. Priėjųs eilutės galą, struktūra yra pushbackinama STL konteineryje.</li>
<li>Pasikartojantis kodas printinimo, skaičiavimo, vardų analižės vietose pakeistas kreipimusi į template funkcijas <code>print_to_file ,calc , names</code></li>
<li>README fail'e pridėtos naudojimosi, įdiegimo instrukcijos.</li>
</ul>
<hr/>
 <h3><a href="https://github.com/gitguuddd/Obj_Duomenu_apdorojimas/releases/tag/v0.5">v0.5</a></h3>
<p>(2019-03-18) <img src="./Memes/liudeselis.jpg" alt="alt text" title="Puikiai veikiantis template&apos;as" class="inline"/>
 <img src="./Memes/tenor.gif" alt="alt text" title="My face when" class="inline"/>
<p><b>Pridėta</b></p><ul>
<li><code>split_n_print</code> ir <code>read_file2</code> funkcijoms sukurti listo ir deque variantai, nes labai pasisekė kurti funkcijų template'us (žiūrėti viršuje :) )</li>
<li><code>t_STL_pick</code> funkcija, kuri leidžia vartotojui pasirinkti ar jis norės dirbti su vektoriumi/deku/listu</li>
<li>Naujuose inputuose sudėtas input handling'as</li>
<li>Į benchmark'o failą (v0.5_laikai.txt) išvedamas ir pasirinkto STL konteinerio pavadinimas</li>
<li>Nustatyta, kad listas lūžta, kai perlipa 19800 saugomų studentų skačių, listo generavimas apribotas iki 10000 studentų.</li>
<li><img src="./Memes/meme3.jpg" alt="alt text" title="Ane" class="inline"/>
</li>
</ul>
<p><b>Koreguota</b></p><ul>
<li>Visur sutvarkytas lygiavimas</li>
<li><code>v0.4_laikai.txt</code> keičiama į <code>v0.5_laikai.txt</code></li>
<li><code>Generuoti studentu faila (v0.4)</code> keičiama į <code>Generuoti studentu faila (v0.5)</code></li>
<li>Pasirodo, kad <code>Generuoti studentu faila (v0.5)</code> funkcija visados generuodavo vienu studentu mažiau nei reikia. Tai sutvarkyta</li>
<li>Namų darbų skaičiaus maksimalus pasirinkimas padidintas iki 1000000</li>
<li>Keliose vietose panaikinti nereikalingi try-catch blokai</li>
<li>Po 0.5 studentų generavimo programa į menių negrįžta ir tiesiog baiga darbą.</li>
</ul>
<hr/>
 <h3><a href="https://github.com/gitguuddd/Obj_Duomenu_apdorojimas/releases/tag/v0.4">v0.4</a></h3>
<p>(2019-03-11) <img src="./Memes/meme2.jpg" alt="alt text" title="Taip, kaltas" class="inline"/>
<p><b>Pridėta</b></p>
<ul>
<li><code>Generuoti studentu faila (v0.4)</code> meniu pasirinkimas kuris apjungia šias naujas funkcijas:</li>
<li><b>overload'inta <code>gen_student</code> funkcija</b>, kuri sugeneruoja nurodytą kiekį studentų su atsitiktinais vardais, pavardėmis , egzaminų įverčiais ir vartotojo nurodytu namų darbų įverčių kiekiu ir šiuos duomenis išveda į failus su atitinkamais pavadinimais <code>generuojamu studentu kiekis + studentu.txt</code></li>
<li><code>read_file2</code> <b>funkcija</b> kuri nuskaito duomenis iš sugeneruotų failų ir juos sudeda į students vektorių.</li>
<li><code>split_n_print</code> <b>funkcija</b> kuri, pagal vartotojo pasirinkimą ([m]ediana/[v]idurkis) suskaičiuoja studentų vektoriuje saugomų studentų galutinius pažymius pagal namų darbų įverčių medianą/namų darbų įverčių vidurkį, išrikiuoja stundentus pagal galutinį pažymį, randa iteratorių ties kuriuo galutinis pažymys tampa lygus 5.0, panaudoja iteratorių skeliant studentų sąrašą į <code>mldc</code> studentus ir <code>L_laivas</code> studentus, juos atspausdina į failus su atitinkamais vardais <code>studentu skaičius + studentu + v/m + mldc/L_laivas</code></li>
<li>Naudojant <code>high_resolution_clock</code> išmatuotas <code>gen_student</code>, <code>read_file2</code> ir <code>split_n_print</code> veikimo laikai dirbant su visais studentų sąrašų variantais (10, 100, 1000, 10000, 100000, 1000000), laikai išvedami į <code>v0.4_laikai.txt</code> failą</li>
<li>Naujose funkcijose pridėtas input/exception handling'as</li>
<li>Dabar galima skelti ir atspausdinti ir duomenis kurie buvo sugeneruoti/įvesti paties naudotojo arba nuskaityti iš kursiokai.txt failo</li>
</ul>
<p><b>Koreguota</b></p>
<ul>
<li>Kursioko Igno D. patarimu mt19937 seedinimas pakeistas iš random device į <code>high_resolution_clock::now().time_since_epoch().count()</code>, nes pasirodo, kad mano kompiuteris neturi random device :(</li>
<li>Sutvarkyti keli minor bug'ai susyję su informacijos išvedimu konsolėje</li>
<li>Pakeistas <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> failas</li>
</ul>
<p><b>Ką artimiausiame release reiktų pataisyti, bet ko tikriausiai nepataisysių</b></p><ul>
<li>Skeliant vartotojo įvestus/sugeneruotus/nuskaitytus duomenis, sudaryti failai ne visados pasižymi puikiu lygiavimu</li>
<li>Sugeneruoti studentų failai (dar neperskelti) irgi nėra puikiai išlygiuoti, nes iškart generuojant ir išvedant nėra galimybės surasti maxname ir maxsurname reikšmių</li>
<li>Studentų sąrašų generavimas ir skėlimas prikuria labaiiii daug failų.</li>
<li>Dėl multiple definition errorų į <code>input.h</code> ir <code>input.cpp</code> teko perkelti split_n_print funkciją, nors ji pagal veikimo principą turėtų priklausyti <code>output.h</code> ir <code>output.cpp</code> failams</li>
<li>Per daug kintamųjų, kurie kaip extern'ai yra deklaruojami <code>mutual.h</code></li>
</ul>
<p><b>Laiko matavimo rezultatai ir pavyzdžiai</b></p><ul>
<li>Visi sarašai buvo sugeneruoti naudojant Release profilį ir -O3 flagą</li>
</ul>
<hr/>
 <h3><a href="https://github.com/gitguuddd/Obj_Duomenu_apdorojimas/releases/tag/v0.3">v0.3</a></h3>
<p>(2019-02-25)</p>
<p><b>Pridėta</b></p><ul>
<li><code>Input.h, Mutual.h, Output.h, Mutual.cpp, Output.cpp, Input.cpp</code></li>
<li>Input handling (pagrinde <code>cin.fail()</code>)</li>
<li>Naudojami <code>vector.reserve()</code> ir <code>vector.shrink_to_fit()</code></li>
<li>Exception handling (<code>try - catch</code>) ties <code>students.push_back</code> ir <code>Stud.nd.push_back</code>, nes pereita prie vektorių atminties rezervavimo</li>
<li>Input handling nuskaitant failą - galima nuskaityti namų darbų pažymius net ir jei jie yra ne skaičiai arba mazesni uz 0/ didesni uz 10 (aptikus - nulinami), jei netinkamas input yra ilgesnis nei 4 simboliai - didelė rizika sugadinti nuskaitytų duomenų tikslumą</li>
<li>Nested switch meniu klaidų spausdinimui</li>
<li>Programos struktūros sekcija <a class="el" href="_r_e_a_d_m_e_8md.html">README.MD</a> faile</li>
<li><img src="./Memes/Meme.jpg" alt="alt text" title="Send Bob" class="inline"/>
</li>
</ul>
<p><b>Koreguota</b></p><ul>
<li>Panaikinti goto, taip pat ir easter egg (LINEKAPUT:), perdaryta switch logika.</li>
<li>Pasirodo, kad senesnių versijų duomenys nebuvo labai tikslūs, duomenys patikslinti. <h2>- kursiokai.txt failas tikslingai sucorruptintas norint išbandyti input handling'a. </h2>
</li>
</ul>
<h3><a href="https://github.com/gitguuddd/Obj_Duomenu_apdorojimas/releases/tag/v0.2">v0.2</a></h3>
<p>(2019-02-18)</p>
<p><b>Pridėta</b></p><ul>
<li>Kursiokai.txt</li>
<li>Rūšiavimas pagal studento vardą ir pavardę</li>
<li>Nuskaitymas iš failo</li>
<li>Galimybė visais būdais gautus duomenis atspausdinti viename output sąraše</li>
<li>Primityvus switch'o error handling'as naudojant goto</li>
<li>Easter egg</li>
</ul>
<p><b>Koreguota</b></p><ul>
<li>Pakeistas <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> failas</li>
</ul>
<p><b>Žinomi trūkumai/ką reikia kuo greičiau ištaisyti</b></p><ul>
<li>Goto switche reikia pakeisti į normalų refactoringa dirbant prie v0.3</li>
<li>Studentų rikiavimas veiks keistokai jei bus naudojami ne vienodo ilgio vardai ir pavardės. <h2>- Nemažai vietų trūksta exception/error handling'o </h2>
</li>
</ul>
<h3><a href="https://github.com/gitguuddd/Obj_Duomenu_apdorojimas/releases/tag/v0.1">v0.1</a></h3>
<p>(2019-02-18)</p>
<p><b>Pridėta</b></p><ul>
<li>CMake failas</li>
<li>Pirmininis programos <code>cpp</code> failas</li>
<li>Alternatyvios programos (su masyvu ) <code>cpp</code> failas (veikiantis bardakas)</li>
</ul>
<p><b>Koreguota</b> </p><h2>- Pakeistas <a class="el" href="_r_e_a_d_m_e_8md.html">README.md</a> failas </h2>
<h2>Benchmark'ai</h2>
<p><b>Truputis informacijos norint suprasti benchmarkus</b></p><ul>
<li>Visi testai yra vykdomi Release profilyje</li>
<li>Visi testai vykdomi su 10 namų darbų.</li>
<li>Egzistuoja keturios skėlimo strategijos <code>A, B, C, D</code></li>
<li>Strategija <code>A</code> - Studentai, kurių galutinis pažymys yra &gt;= 5.0 yra perkeliami į <code>mldc</code> STL konteinerį, kurių yra mažesnis už 5.0 - į <code>L_laivas</code> STL konteinerį. Studentai iš pirminio STL konteinerio netrinami</li>
<li>Strategija <code>B</code> - Studentai, kurių galutinis pažymys yra &gt;=5.0 yra perkeliami į <code>mldc_students</code> STL konteinerį, iš pirminio studentų STL konteinerio šie studentai yra pašalinami, pirminis STL'as tampa <code>L_laivas</code> STL konteineriu</li>
<li>Strategija <code>C</code> - Pirminis studentų STL konteineris yra išrikiuojamas didėjimo tvarka pagal galutinį pažymį, naudojant <code>std::upper_bound</code> randamas iteratorių <code>up</code>, ties kuriuo reikšmės perlipa <code>4.999999999</code> ribą. Šis iteratoriaus yra naudojamas <code>mldc_students</code> STL konteinerio kontruktoriuje, resize<code>inant pirminį STL konteinerį yra gaunamas</code><code>L_laivas</code><code>STL konteineris.</code></li>
<li><code>Strategija</code><code>D</code><code>- Papildomos užduoties siūlomi skėlimo algoritmai:</code><code>m</code><code>algoritmas, kuris skolininkus perkelia į atskirą STL konteinerį, šiuos studentus ištrina iš pirminio STL konteinerio per</code><code>erase</code><code>funkciją,</code><code>k</code><code>algoritmas, kuris skolininkus irgi perkelia į atskirą STL konteinerį, kietus studentus perkelia į pirminio STL konteinerio priekį ir naudojant</code><code>resize</code><code>ir</code><code>shrink_to_fit</code><code>funkcijas iš šio STL konteinerio ištrina perteklinius kietus studentus/skolininkus ir atlaisvina atmintį -</code><code>vid</code><code>ir</code><code>med</code>` atitinkamai reiškia, kad teste galutinis pažymys buvo skaičiuotas pagal namų darbų įverčių vidurkį arba medianą</li>
</ul>
<p><b>v1.1</b></p>
<p><b>Programos veikimo laikų palyginimas naudojant <code>Stud</code> struktūra arba <code>Stud</code> klasę</b></p>
<ul>
<li>Šiam ir sekantiems (&gt;=v1.1) sparčiausiems testams bus naudojama <code>A</code> dalijimo strategija</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone"><code>vector&lt;struct Stud&gt;</code>  </th><th class="markdownTableHeadNone"><code>vector&lt;class Stud&gt;</code>   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000 v  </td><td class="markdownTableBodyNone">3.94281 s.  </td><td class="markdownTableBodyNone">1.73632 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000 v  </td><td class="markdownTableBodyNone">39.8862 s.  </td><td class="markdownTableBodyNone">35.73931 s.   </td></tr>
</table>
<ul>
<li>Iš lentelės duomenų matome, kad <code>Stud</code> realizacija per klasę sugebėjo paspartinti A strategiją.</li>
</ul>
<p><b>Programos veikimo laikų palyginimas naudojant skirtingus optimizavimo flag'us</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone"></th><th class="markdownTableHeadNone">-O1  </th><th class="markdownTableHeadNone">-O2  </th><th class="markdownTableHeadNone">-O3   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000 v  </td><td class="markdownTableBodyNone">3.799484 s.  </td><td class="markdownTableBodyNone">3.532669 s.  </td><td class="markdownTableBodyNone">3.595513 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000 v  </td><td class="markdownTableBodyNone">41.12474 s.  </td><td class="markdownTableBodyNone">40.11205 s.  </td><td class="markdownTableBodyNone">34.53586 s.   </td></tr>
</table>
<ul>
<li>Kaip ir reikėjo tikėtis - O3 optimizacijos flag'as labiausiai padėjo programai. Neaiškumą lyginant 100000v -O2 ir 100000v -O3 galima paaiškinti tuo, kad duomenų tikslumui koją galėjo pakišti atsitiktinis kompiuteriuo apkrovos kitimas.</li>
<li><img src="./Memes/Time.jpg" alt="alt text" title="Blogi laikai, seniai karo nebuvo..." class="inline"/>
</li>
</ul>
<p><b>v1.0.1</b></p>
<p><b>Papidomos užduoties skėlimo algoritmų (D strategijos) laikai dirbant su vector arba deque</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">STL konteineris  </th><th class="markdownTableHeadNone">std::vector&lt;&gt;  </th><th class="markdownTableHeadNone">std::deque&lt;&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000 m  </td><td class="markdownTableBodyNone">4.71733 s.  </td><td class="markdownTableBodyNone">1.65675 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000 k  </td><td class="markdownTableBodyNone">11.7855 s.  </td><td class="markdownTableBodyNone">0.004923 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000 m  </td><td class="markdownTableBodyNone">497.472 s.  </td><td class="markdownTableBodyNone">175.256 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000 k  </td><td class="markdownTableBodyNone">3144.7 s.  </td><td class="markdownTableBodyNone">0.061832 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000 m  </td><td class="markdownTableBodyNone">inf.  </td><td class="markdownTableBodyNone">inf.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000 k  </td><td class="markdownTableBodyNone">inf.  </td><td class="markdownTableBodyNone">0.600361 s.   </td></tr>
</table>
<ul>
<li>Iš lentelės duomenų matome, kad <code>m</code> algoritmas vektoriui buvo palankesnis nei <code>k</code> algoritmas.Tai galima paaiškinti tuo, kad <code>k</code> algoritme naudojamas kėlimas į priekį vektoriui yra O(N) sudėtingumo funkcija ir gerokai apsunkina vektoriaus darba - labai daug laiko užima saugomų objektų perstumdymas.</li>
<li>Tačiau deque atveju <code>k</code> algoritmas buvo totalus game winner, nes deque turi <code>push_front</code> funkciją ir ją labai sėkmingai panaudoja <code>k</code> algoritmą.Tai yra vienintelė kombinacija, kuri pabaigė darbą su 1000000 studentų.</li>
</ul>
<p><b>v1.0</b></p>
<p><b>Skirtingų STL konteineriu naudojamos atminties kiekis pritaikant a strategiją</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">STL konteineris  </th><th class="markdownTableHeadCenter">std::vector&lt;&gt;  </th><th class="markdownTableHeadCenter">std::deque&lt;&gt;  </th><th class="markdownTableHeadCenter">std::list&lt;&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Naudojamos atminties kiekis programos pradžioje  </td><td class="markdownTableBodyCenter">635 MB  </td><td class="markdownTableBodyCenter">966.6 MB  </td><td class="markdownTableBodyCenter">971.6 MB   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10 skirtumas  </td><td class="markdownTableBodyCenter">+ 0.2 MB  </td><td class="markdownTableBodyCenter">+ 0.2 MB  </td><td class="markdownTableBodyCenter">+ 0.3 MB   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100 skirtumas  </td><td class="markdownTableBodyCenter">+ 0.3 MB  </td><td class="markdownTableBodyCenter">+ 0.4 MB  </td><td class="markdownTableBodyCenter">+ 0.7 MB   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000 skirtumas  </td><td class="markdownTableBodyCenter">+ 0.9 MB  </td><td class="markdownTableBodyCenter">+ 1.8 MB  </td><td class="markdownTableBodyCenter">+ 0.9 MB   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000 skirtumas  </td><td class="markdownTableBodyCenter">+ 3.2 MB  </td><td class="markdownTableBodyCenter">+ 3.9 MB  </td><td class="markdownTableBodyCenter">+ 2.4 MB   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000 skirtumas  </td><td class="markdownTableBodyCenter">+ 34.1 MB  </td><td class="markdownTableBodyCenter">+ 30.8 MB  </td><td class="markdownTableBodyCenter">+ 36.9 MB   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000 skirtumas  </td><td class="markdownTableBodyCenter">+ 616.2 MB  </td><td class="markdownTableBodyCenter">+ 293.4 MB  </td><td class="markdownTableBodyCenter">+ 322.6 MB   </td></tr>
</table>
<ul>
<li>Iš lentelės duomenų matome, kad <code>vector</code> STL konteineris yra labai jautrus tokiam atminties švaistymui</li>
</ul>
<p><b>Programos benchmark'as prieš optimizuojant a ir b strategijas</b></p><ul>
<li>a ir b strategijoms buvo būdingas štai toks kodas <div class="fragment"><div class="line">a strategija</div><div class="line"></div><div class="line">if(pchoice==&#39;v&#39;)</div><div class="line">            for (Stud&amp; Stud : students_d)</div><div class="line">                (Stud.vid2&gt;=test.vid2)?mldc_d.push_back(Stud):L_laivsd.push_back(Stud);</div><div class="line">        else if(pchoice==&#39;m&#39;)</div><div class="line">            for (Stud&amp; Stud : students_d)</div><div class="line">                (Stud.mvid&gt;=test.mvid)?mldc_d.push_back(Stud):L_laivsd.push_back(Stud);}</div><div class="line"></div><div class="line">b strategija</div><div class="line"></div><div class="line">if(pchoice==&#39;v&#39;){</div><div class="line">            std::copy_if(students_d.begin(), students_d.end(), std::back_inserter(mldc_students_d) ,[](auto v) {return v.vid2&gt;test.vid2;});</div><div class="line">            students_d.erase(std::remove_if(students_d.begin(),students_d.end(),[](auto v) {return v.vid2&gt;test.vid2;}),students_d.end());</div><div class="line">        }</div><div class="line">        if (pchoice==&#39;m&#39;){</div><div class="line">            std::copy_if(students_d.begin(), students_d.end(), std::back_inserter(mldc_students_d) ,[](auto v) {return v.mvid&gt;test.mvid;});</div><div class="line">            students_d.erase(std::remove_if(students_d.begin(),students_d.end(),[](auto v) {return v.mvid&gt;test.mvid;}),students_d.end());</div><div class="line">        }</div></div><!-- fragment --> <table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">STL konteineris  </th><th class="markdownTableHeadNone">std::vector&lt;&gt;  </th><th class="markdownTableHeadNone">std::deque&lt;&gt;  </th><th class="markdownTableHeadNone">std::list&lt;&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10med. A  </td><td class="markdownTableBodyNone">0.004149 s.  </td><td class="markdownTableBodyNone">0.007609 s.  </td><td class="markdownTableBodyNone">0.004057 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10vid. A  </td><td class="markdownTableBodyNone">0.004931 s.  </td><td class="markdownTableBodyNone">0.004841 s.  </td><td class="markdownTableBodyNone">0.004829 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10med. B  </td><td class="markdownTableBodyNone">0.006466 s.  </td><td class="markdownTableBodyNone">0.008885 s.  </td><td class="markdownTableBodyNone">0.005813 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10vid. B  </td><td class="markdownTableBodyNone">0.00897 s.  </td><td class="markdownTableBodyNone">0.006701 s.  </td><td class="markdownTableBodyNone">0.006041 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10med. C  </td><td class="markdownTableBodyNone">0.004168 s.  </td><td class="markdownTableBodyNone">0.009851 s.  </td><td class="markdownTableBodyNone">0.005049 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10vid .C  </td><td class="markdownTableBodyNone">0.003733 s.  </td><td class="markdownTableBodyNone">0.003545 s.  </td><td class="markdownTableBodyNone">0.004209 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100med. A  </td><td class="markdownTableBodyNone">0.008164 s.  </td><td class="markdownTableBodyNone">0.008695 s.  </td><td class="markdownTableBodyNone">0.007641 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100vid. A  </td><td class="markdownTableBodyNone">0.006982 s.  </td><td class="markdownTableBodyNone">0.008061 s.  </td><td class="markdownTableBodyNone">0.007104 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100med. B  </td><td class="markdownTableBodyNone">0.008847 s.  </td><td class="markdownTableBodyNone">0.00708 s.  </td><td class="markdownTableBodyNone">0.007023 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100vid. B  </td><td class="markdownTableBodyNone">0.010152 s.  </td><td class="markdownTableBodyNone">0.10384 s.  </td><td class="markdownTableBodyNone">0.006812 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100med. C  </td><td class="markdownTableBodyNone">0.008884 s.  </td><td class="markdownTableBodyNone">0.007204 s.  </td><td class="markdownTableBodyNone">0.009949 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100vid. C  </td><td class="markdownTableBodyNone">0.009582 s.  </td><td class="markdownTableBodyNone">0.009121 s.  </td><td class="markdownTableBodyNone">0.009793 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000med. A  </td><td class="markdownTableBodyNone">0.045407 s.  </td><td class="markdownTableBodyNone">0.030931 s.  </td><td class="markdownTableBodyNone">0.045012 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000vid. A  </td><td class="markdownTableBodyNone">0.035778 s.  </td><td class="markdownTableBodyNone">0.031794 s.  </td><td class="markdownTableBodyNone">0.038341 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000med. B  </td><td class="markdownTableBodyNone">0.033443 s.  </td><td class="markdownTableBodyNone">0.034769 s.  </td><td class="markdownTableBodyNone">0.029803 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000vid. B  </td><td class="markdownTableBodyNone">0.034354 s.  </td><td class="markdownTableBodyNone">0.039826 s.  </td><td class="markdownTableBodyNone">0.03594 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000med. C  </td><td class="markdownTableBodyNone">0.03992 s.  </td><td class="markdownTableBodyNone">0.0331154 s.  </td><td class="markdownTableBodyNone">0.039117 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000vid. C  </td><td class="markdownTableBodyNone">0.054393 s.  </td><td class="markdownTableBodyNone">0.034342 s.  </td><td class="markdownTableBodyNone">0.032307 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000med. A  </td><td class="markdownTableBodyNone">0.324686 s.  </td><td class="markdownTableBodyNone">0.256643 s.  </td><td class="markdownTableBodyNone">0.263765 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000vid. A  </td><td class="markdownTableBodyNone">0.289927 s.  </td><td class="markdownTableBodyNone">0.25493 s.  </td><td class="markdownTableBodyNone">0.276006 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000med. B  </td><td class="markdownTableBodyNone">0.320333 s.  </td><td class="markdownTableBodyNone">0.260436 s.  </td><td class="markdownTableBodyNone">0.280009 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000vid. B  </td><td class="markdownTableBodyNone">0.263332 s.  </td><td class="markdownTableBodyNone">0.323455 s.  </td><td class="markdownTableBodyNone">0.288229 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000med. C  </td><td class="markdownTableBodyNone">0.411803 s.  </td><td class="markdownTableBodyNone">0.298277 s.  </td><td class="markdownTableBodyNone">0.309161 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000vid. C  </td><td class="markdownTableBodyNone">0.38127 s.  </td><td class="markdownTableBodyNone">1.135304 s.  </td><td class="markdownTableBodyNone">0.349428 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000med. A  </td><td class="markdownTableBodyNone">3.065104 s.  </td><td class="markdownTableBodyNone">2.835945 s.  </td><td class="markdownTableBodyNone">3.072419 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000vid. A  </td><td class="markdownTableBodyNone">1.805628 s.  </td><td class="markdownTableBodyNone">2.696151 s.  </td><td class="markdownTableBodyNone">3.472723 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000med. B  </td><td class="markdownTableBodyNone">4.301535 s.  </td><td class="markdownTableBodyNone">2.959285 s.  </td><td class="markdownTableBodyNone">2.5732259 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000vid. B  </td><td class="markdownTableBodyNone">3.135811 s.  </td><td class="markdownTableBodyNone">3.096747 s.  </td><td class="markdownTableBodyNone">3.225552 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000med. C  </td><td class="markdownTableBodyNone">4.298746 s.  </td><td class="markdownTableBodyNone">2.977456 s.  </td><td class="markdownTableBodyNone">3.801098 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000vid. C  </td><td class="markdownTableBodyNone">3.871526 s.  </td><td class="markdownTableBodyNone">2.391564 s.  </td><td class="markdownTableBodyNone">3.627411 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000med. A  </td><td class="markdownTableBodyNone">29.86407 s.  </td><td class="markdownTableBodyNone">27.74826 s.  </td><td class="markdownTableBodyNone">30.25982 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000vid. A  </td><td class="markdownTableBodyNone">34.03236 s.  </td><td class="markdownTableBodyNone">28.82433 s.  </td><td class="markdownTableBodyNone">31.97502 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000med. B  </td><td class="markdownTableBodyNone">32.57199 s.  </td><td class="markdownTableBodyNone">30.12409 s.  </td><td class="markdownTableBodyNone">31.86533 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000vid. B  </td><td class="markdownTableBodyNone">31.42009 s.  </td><td class="markdownTableBodyNone">32.16509 s.  </td><td class="markdownTableBodyNone">30.41746 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000med. C  </td><td class="markdownTableBodyNone">40.5757 s.  </td><td class="markdownTableBodyNone">29.35842 s.  </td><td class="markdownTableBodyNone">35.62856 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000vid. C  </td><td class="markdownTableBodyNone">38.07228 s.  </td><td class="markdownTableBodyNone">38.83359 s.  </td><td class="markdownTableBodyNone">37.20177 s.   </td></tr>
</table>
</li>
<li>Iš lentelės duomenų matome, kad mano programos atveju dirbant su skirtingais STL konteineriais programa sugaišta panašų kiekį laiko</li>
</ul>
<p><b>Programos darbas po a ir b strategijų optimizavimo</b></p><ul>
<li><code>c</code> strategija į lentelę neįtraukta, nes ji nesikeitė. Optimizavus <code>b</code> strategiją, savo veikimo principu ji tapo labai panaši į <code>c</code> strategiją</li>
</ul>
<div class="fragment"><div class="line">a ir b strategijos</div><div class="line"></div><div class="line">if(pchoice==&#39;v&#39;)</div><div class="line">                up_l=stable_partition(students_l.begin(),students_l.end(),[](auto v) {return v.vid2&lt;test.vid2;});}</div><div class="line">            else if(pchoice==&#39;m&#39;)</div><div class="line">                up_l=stable_partition(students_l.begin(),students_l.end(),[](auto v) {return v.mvid&lt;test.mvid;});</div></div><!-- fragment --><ul>
<li>Šiuo atveju rastas <code>up_l</code> iteratorius <code>a</code> strategijos atveju yra panaudojamas konstruojant <code>L_laivasl</code> ir <code>mldc_l</code> listus, <code>b</code> strategijos atveju šis iteratorius panaujomas konstruojant <code>mldc_students_l</code> list'ą</li>
</ul>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">STL konteineris  </th><th class="markdownTableHeadNone">std::vector&lt;&gt;  </th><th class="markdownTableHeadNone">std::deque&lt;&gt;  </th><th class="markdownTableHeadNone">std::list&lt;&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10med. A  </td><td class="markdownTableBodyNone">0.004988 s.  </td><td class="markdownTableBodyNone">0.007974 s.  </td><td class="markdownTableBodyNone">0.0039868 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10vid. A  </td><td class="markdownTableBodyNone">0.005936 s.  </td><td class="markdownTableBodyNone">0.002994 s.  </td><td class="markdownTableBodyNone">0.002991 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10med. B  </td><td class="markdownTableBodyNone">0.004985 s.  </td><td class="markdownTableBodyNone">0.005987 s.  </td><td class="markdownTableBodyNone">0.003991 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10vid. B  </td><td class="markdownTableBodyNone">0.004985 s.  </td><td class="markdownTableBodyNone">0.003962 s.  </td><td class="markdownTableBodyNone">0.0049816 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100med. A  </td><td class="markdownTableBodyNone">0.011115 s.  </td><td class="markdownTableBodyNone">0.008017 s.  </td><td class="markdownTableBodyNone">0.005984 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100vid. A  </td><td class="markdownTableBodyNone">0.009008 s.  </td><td class="markdownTableBodyNone">0.005985 s.  </td><td class="markdownTableBodyNone">0.00798 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100med. B  </td><td class="markdownTableBodyNone">0.006915 s.  </td><td class="markdownTableBodyNone">0.007979 s.  </td><td class="markdownTableBodyNone">0.008972 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100vid. B  </td><td class="markdownTableBodyNone">0.007977 s.  </td><td class="markdownTableBodyNone">0.007942 s.  </td><td class="markdownTableBodyNone">0.008011 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000med. A  </td><td class="markdownTableBodyNone">0.031731 s.  </td><td class="markdownTableBodyNone">0.03291 s.  </td><td class="markdownTableBodyNone">0.034002 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000vid. A  </td><td class="markdownTableBodyNone">0.029913 s.  </td><td class="markdownTableBodyNone">0.037914 s.  </td><td class="markdownTableBodyNone">0.030915 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000med. B  </td><td class="markdownTableBodyNone">0.030947 s.  </td><td class="markdownTableBodyNone">0.034943 s.  </td><td class="markdownTableBodyNone">0.032974 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000vid. B  </td><td class="markdownTableBodyNone">0.031914 s.  </td><td class="markdownTableBodyNone">0.032948 s.  </td><td class="markdownTableBodyNone">0.030878 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000med. A  </td><td class="markdownTableBodyNone">0.260302 s.  </td><td class="markdownTableBodyNone">0.317148 s.  </td><td class="markdownTableBodyNone">0.2702790 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000vid. A  </td><td class="markdownTableBodyNone">0.291251 s.  </td><td class="markdownTableBodyNone">0.277272 s.  </td><td class="markdownTableBodyNone">0.278252 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000med. B  </td><td class="markdownTableBodyNone">0.266288 s.  </td><td class="markdownTableBodyNone">0.302154 s.  </td><td class="markdownTableBodyNone">0.274262 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000vid. B  </td><td class="markdownTableBodyNone">0.281282 s.  </td><td class="markdownTableBodyNone">0.268279 s.  </td><td class="markdownTableBodyNone">0.279253 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000med. A  </td><td class="markdownTableBodyNone">2.902221 s.  </td><td class="markdownTableBodyNone">3.120653 s.  </td><td class="markdownTableBodyNone">3.318164 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000vid. A  </td><td class="markdownTableBodyNone">3.013925 s.  </td><td class="markdownTableBodyNone">3.081752 s.  </td><td class="markdownTableBodyNone">3.280935 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000med. B  </td><td class="markdownTableBodyNone">2.917195 s.  </td><td class="markdownTableBodyNone">2.934117 s.  </td><td class="markdownTableBodyNone">3.274237 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000vid. B  </td><td class="markdownTableBodyNone">3.018921 s.  </td><td class="markdownTableBodyNone">3.047839 s.  </td><td class="markdownTableBodyNone">2.751651 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000med. A  </td><td class="markdownTableBodyNone">28.70126 s.  </td><td class="markdownTableBodyNone">29.83323 s.  </td><td class="markdownTableBodyNone">29.43332 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000vid. A  </td><td class="markdownTableBodyNone">29.14299 s.  </td><td class="markdownTableBodyNone">30.59215 s.  </td><td class="markdownTableBodyNone">29.58191 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000med. B  </td><td class="markdownTableBodyNone">29.73743 s.  </td><td class="markdownTableBodyNone">29.01442 s.  </td><td class="markdownTableBodyNone">29.41837 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000vid. B  </td><td class="markdownTableBodyNone">28.89283 s.  </td><td class="markdownTableBodyNone">30.00679 s.  </td><td class="markdownTableBodyNone">29.0454 s.   </td></tr>
</table>
<p><b>v0.5</b> <b>Testavimo rezultatai naudojant skirtingus STL konteinerius</b></p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">STL konteineris  </th><th class="markdownTableHeadNone">std::vector&lt;&gt;  </th><th class="markdownTableHeadNone">std::deque&lt;&gt;  </th><th class="markdownTableHeadNone">std::list&lt;&gt;   </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10vid  </td><td class="markdownTableBodyNone">0.009014 s.  </td><td class="markdownTableBodyNone">0.005128 s.  </td><td class="markdownTableBodyNone">0.003992 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10med  </td><td class="markdownTableBodyNone">0.006949 s.  </td><td class="markdownTableBodyNone">0.002992 s.  </td><td class="markdownTableBodyNone">0.004979 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100vid  </td><td class="markdownTableBodyNone">0.007017 s.  </td><td class="markdownTableBodyNone">0.009007 s.  </td><td class="markdownTableBodyNone">0.00698 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100med  </td><td class="markdownTableBodyNone">0.007977 s.  </td><td class="markdownTableBodyNone">0.007982 s.  </td><td class="markdownTableBodyNone">0.008977 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000vid  </td><td class="markdownTableBodyNone">0.035963 s.  </td><td class="markdownTableBodyNone">0.040521 s.  </td><td class="markdownTableBodyNone">0.4627448 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000med  </td><td class="markdownTableBodyNone">0.031945 s.  </td><td class="markdownTableBodyNone">0.032907 s.  </td><td class="markdownTableBodyNone">0.191491 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">10000vid  </td><td class="markdownTableBodyNone">0.328088 s.  </td><td class="markdownTableBodyNone">0.323124 s.  </td><td class="markdownTableBodyNone">7.471561 s.   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">10000med  </td><td class="markdownTableBodyNone">0.310168 s.  </td><td class="markdownTableBodyNone">0.308523 s.  </td><td class="markdownTableBodyNone">19.684555 s.   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">100000vid  </td><td class="markdownTableBodyNone">3.757647 s.  </td><td class="markdownTableBodyNone">3.352958 s.  </td><td class="markdownTableBodyNone">Nėra   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">100000med  </td><td class="markdownTableBodyNone">3.35035 s.  </td><td class="markdownTableBodyNone">3.537462 s.  </td><td class="markdownTableBodyNone">Nėra   </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">1000000vid  </td><td class="markdownTableBodyNone">37.74918 s.  </td><td class="markdownTableBodyNone">42.60728 s.  </td><td class="markdownTableBodyNone">Nėra   </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">1000000med  </td><td class="markdownTableBodyNone">41.558277 s.  </td><td class="markdownTableBodyNone">37.02453 s.  </td><td class="markdownTableBodyNone">Nėra   </td></tr>
</table>
<p><b>v0.4</b></p><ul>
<li><b>Laiko matavimo rezultatų failo vaizdas visuose sąrašuose generuojant po 10 namų darbų pažymių ir pasirinkus galutinio pažymio skaičiavimą pagal vidurkį</b> <img src="./Memes/.png" alt="alt text" title=":O" class="inline"/>
</li>
<li><b>Laiko matavimo rezultatų failo vaizdas visuose sąrašuose generuojant po 10 namų darbų pažymių ir pasirinkus galutinio pažymio skaičiavimą pagal medianą</b> ![alt text](./Memes/med10.png ":)")</li>
</ul>
<hr/>
 <h2>Programos struktūra</h2>
<ul>
<li><code>Input.h</code> ir <code>Input.cpp</code> funkcijos/kintamieji/include'ai susyję su duomenų įvedimu</li>
<li><code>Output.h</code>ir <code>Output.cpp</code> funkcijos/kintamieji/include'ai susyję su duomenų išvedimu</li>
<li><code>Mutual.h</code>ir <code>Mutual.cpp</code> funkcijos/kintamieji/include'ai bendri visai programai (<code>#include iostream</code>,<code>handle_input()</code> )</li>
<li><code><a class="el" href="main_8cpp.html">main.cpp</a></code> pagrindinis failas - meniu</li>
<li><code>Stud.h</code> ir <code>Stud.cpp</code> Stud klasei reikalingi include<code>ai ir funkcijos -</code><code>Important_Values.h</code><code>ir</code><code>Important_Values.cpp</code><code>sklandų programos veikimą užtikrinantys kintamieji ir su jais dirbančios funkcijos -</code><code>Humie.h</code><code>ir</code><code>Humie.cpp</code><code>Humie klasei reikalingi include</code>ai ir funkcijos</li>
<li><code>Timer.h</code> timer klasė </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.15
</small></address>
</body>
</html>
